## mysql调优相关
---
> 参考整理 视频 马士兵相关调优课程及相关网站数据

---

- ### 性能监控
  - show profile 查询剖析工具，查询query得相关性能
    - 默认关闭，使用 set profiling=1; 开启
    - show profiles; 查看所有查询的时间(时间更精确)
    - show profile for query 1; 查询具体ID对应的信息，包括
      starting、optimizing、statistics、preparing、executing等具体的过程时间
    - show  profile block io(io操作)/context switches(上下文切换)/cpu/ipc for query n 查询具体的项的性能
  - performance schema mysql5.5之后开始引入的，旨在更加容易的监控mysql
  - show processlist 查看连接的线程个数，观察是否又大量线程处于不正常的状态 

---

- ### schema与数据类型优化
  - 数据类型的优化(相关结论)
    - 尽量使用可以正确存储数据的最小数据类型，如列中只有0、1，使用tinyint即可;日期使用mysql自带的日期类型(通常使用timestamp)，而不使用字符串存储;ip地址使用整型存储，不适用字符串;还可以使用枚举替代字符串类型(但目前没有使用过)等，(具体详细内容可看Mysql调优对应xmind)
    - 范式和反范式的使用:范式的主要作用是去除冗余，但在有些场景下，需要数据表的冗余。如查询订单的详细信息时，可以将有些字段存入订单表中，避免再查询用户表。
    - 主键的选择:主键通常分为**业务主键**和**代理主键**，推荐使用代理主键(之前项目使用的雪花算法生成的代理主键，顺序主键，不会导致频繁的页分裂，影响效率)
    - 字符集的选择:存储中文时，字符集推荐使用utf8mb4，因为utf8字符集最多只支持3个字符，但表情、特殊中文需要4个字节才可以存储。通常选用utf8字符集
    - 存储引擎的选择:主要针对Innodb和Myisam引擎 (Memory引擎为内存数据库，使用情况较小)。一般Innodb引擎常用，Myisam通常用在只读的情况下，效率更高。
    - 适当的数据冗余:旨在减少join的使用。
    - 适当拆分:针对不常用且长度较长的数据，可以将该数据从数据表中拆分出来。减少磁盘块的占用，提高效率

---

- ### 执行计划
  - explain select * from tmp 通过explain语句查看该语句是否使用索引？查询的row行数？是否使用内排序等。
  - 优化的关键点主要在于row处优化，row的数值越少，效率越高。同时，尽量让 type栏在range范围以上 
    system > const > eq_ref > ref > fulltext > ref_or_null > index_merge > unique_subquery > index_subquery > range > index > ALL

---

- ### 通过索引优化
  - 索引的优点
    - 减少服务器需要扫描的数据量
    - 帮助服务器避免排序和临时表(索引本身就已排序好)
    - 将随机io变成顺序io
  - 索引的分类:
    - 普通索引 最基本的索引，直接 add index index_name(column) 即可
    - 唯一索引 与普通索引相似，但索引的列必须唯一，允许有空值，unique。
    - 主键索引 特殊的唯一索引，不允许有空值。如果没有主键，则会Unique Key做主键，如果没有unique,则系统生成一个内部的rowid做主键(如果unique key有空值如何处理)
      只有主键索引的键和值才在一起，其他的索引都只存放索引值和对应行的主键值(由于该特性，查询时有回表的操作。但组合索引有额外特例。)
    - 全文索引 针对较大的数据使用，但一般不建议使用，耗时、耗空间
    - 组合索引 提高查询效率，遵循最做匹配原则
  - 相关技术名词:
    - 回表
    - 覆盖索引
    - 最左匹配
    - 索引下推: (还不理解)
  - 索引常采用的数据结构:
    - 哈希表: 
      
      - 哈希表在mysql中主要用于myisam数据库，旨在更高效率的查询。但只能根据哈希值查询，不能范围查找、无法排序，同时需要考虑键值冲突的问题(可通过更高效的扰动算法优化)
    - B+树:
      - 顶层节点只存储索引的键值和指向下一层地址块的指针(innodb每次读取一块16kb的数据)
      - 叶子节点存储索引及完整数据
      - 问题：三层的B+树，可以存储多少条数据 。
        
        > 假设 key=int类型，则占8个字节。每个指针是6个字节，总占用14个字节。16kb=16384字节，一块共有16384/16=11710个键+指针。两层则共有 11710*11710个指针指向数据块。假设一条数据1kb，一个数据块即存储16条数据，三层B+树功能存储 11710*11710*16=2193w
    
  - 索引的匹配方式
    - 全值匹配: 和索引中的所有列进行匹配
    - 匹配最左前缀: 只匹配前面的几列
    - 匹配列前缀: like查询时 ’column%' 才会走索引。否则索引无效
    - 匹配范围值: > < 这种。索引的使用截至到范围列，后续列就算在联合索引中，依然失效
    - 只访问索引的查询: 针对组合索引，select 的字段即为 组合索引的列，不进行回表操作
    - **注意**:索引要完全按照对应的字段类型来赋值，否则索引失效
  - 聚簇索引与非聚簇索引
    - 聚簇索引: 根据主键来构建，叶子节点存放该主键对应的一行记录。主要针对innodb。innodb引擎中，索引和数据全部都放在一个文件中
    - 非聚簇索引: 数据文件跟索引文件分开存放。myisam引擎，.frm存储表定义，.myi文件存储索引文件，.myd文件存储数据文件。索引文件中，存储的是索引对应的数据地址
  