## mysql调优相关
---
> 参考整理 视频 马士兵相关调优课程及相关网站数据
>
> in和exists的区别，参考网址: https://www.cnblogs.com/zhuyeshen/p/10955417.html
>  
> join 相关 参考网址： https://www.cnblogs.com/shengdimaya/p/7123069.html

---

- ### 性能监控
  - show profile 查询剖析工具，查询query得相关性能
    - 默认关闭，使用 set profiling=1; 开启
    - show profiles; 查看所有查询的时间(时间更精确)
    - show profile for query 1; 查询具体ID对应的信息，包括
      starting、optimizing、statistics、preparing、executing等具体的过程时间
    - show  profile block io(io操作)/context switches(上下文切换)/cpu/ipc for query n 查询具体的项的性能
  - performance schema mysql5.5之后开始引入的，旨在更加容易的监控mysql
  - show processlist 查看连接的线程个数，观察是否有大量线程处于不正常的状态 

---

- ### schema与数据类型优化
  - 数据类型的优化(相关结论)
    - 尽量使用可以正确存储数据的最小数据类型，如列中只有0、1，使用tinyint即可;日期使用mysql自带的日期类型(通常使用timestamp)，而不使用字符串存储;ip地址使用整型存储，不适用字符串;还可以使用枚举替代字符串类型(但目前没有使用过)等，(具体详细内容可看Mysql调优对应xmind)
    - 范式和反范式的使用:范式的主要作用是去除冗余，但在有些场景下，需要数据表的冗余。如查询订单的详细信息时，可以将有些字段存入订单表中，避免再查询用户表。
    - 主键的选择:主键通常分为**业务主键**和**代理主键**，推荐使用代理主键(之前项目使用的雪花算法生成的代理主键，顺序主键，不会导致频繁的页分裂，影响效率)
    - 字符集的选择:存储中文时，字符集推荐使用utf8mb4，因为utf8字符集最多只支持3个字符，但表情、特殊中文需要4个字节才可以存储。通常选用utf8字符集
    - 存储引擎的选择:主要针对Innodb和Myisam引擎 (Memory引擎为内存数据库，使用情况较小)。一般Innodb引擎常用，Myisam通常用在只读的情况下，效率更高。
    - 适当的数据冗余:旨在减少join的使用(可以通过第三张关联表进行查询)。
    - 适当拆分:针对不常用且长度较长的数据，可以将该数据从数据表中拆分出来。减少磁盘块的占用，提高效率

---

- ### 执行计划
  - explain select * from tmp 通过explain语句查看该语句是否使用索引？查询的row行数？是否使用内排序等。
  - 优化的关键点主要在于row处优化，row的数值越少，效率越高。同时，尽量让 type栏在range范围以上 
    system > const > eq_ref > ref > fulltext > ref_or_null > index_merge > unique_subquery > index_subquery > range > index > ALL

---

- ### 通过索引优化
  - 索引的优点
    - 减少服务器需要扫描的数据量
    - 帮助服务器避免排序和临时表(索引本身就已排序好)
    - 将随机io变成顺序io
    
    ---
    
  - 索引的分类:
    - 普通索引 最基本的索引，直接 add index index_name(column) 即可
    
    - 唯一索引 与普通索引相似，但索引的列必须唯一，允许有空值，unique。
    
    - 主键索引 特殊的唯一索引，不允许有空值。如果没有主键，则会Unique Key做主键，如果没有unique,则系统生成一个内部的rowid做主键(如果unique key有空值如何处理)
      只有主键索引的键和值才在一起，其他的索引都只存放索引值和对应行的主键值(由于该特性，查询时有回表的操作。但组合索引有额外特例。)
  
      主键索引也可以理解为聚簇索引么？
  
    - 全文索引 针对较大的数据使用，但一般不建议使用，耗时、耗空间
    
    - 组合索引 提高查询效率，遵循最左匹配原则
    
    ---
    
  - 相关技术名词:
    - 回表：主键索引树只有最后一层才存储对应数据，普通索引树叶子节点存储索引及对应主键。查询普通索引时会根据主键返回主键索引树，查找对应的行数据。
    - 覆盖索引：只需要在一棵索引树上就能获取SQL所需的所有列数据，无需回表，速度更快。常见的方法是将被查询的字段，建立到联合索引中 
    - 最左匹配：组合索引的情况下，索引会根据从左到右的顺序依次对索引进行匹配
    - 索引下推: (还不理解)  https://segmentfault.com/a/1190000039869289
    
    ---
    
  - 索引常采用的数据结构:
    - 哈希表: 
      
      - 哈希表在mysql中主要用于memory数据库，旨在更高效率的查询。但只能根据哈希值查询，不能范围查找、无法排序，同时需要考虑键值冲突的问题(可通过更高效的扰动算法优化)
    - B+树:
      - 顶层节点只存储索引的键值和指向下一层地址块的指针(innodb每次读取一块16kb的数据)
      - 叶子节点存储索引及完整数据
      - 问题：三层的B+树，可以存储多少条数据 。
        
        > 假设 key=int类型，则占8个字节。每个指针是6个字节，总占用14个字节。16kb=16384字节，一块共有16384/14=11710个键+指针。两层则共有 11710×11710个指针指向数据块。假设一条数据1kb，一个数据块即存储16条数据，三层B+树功能存储 11710×11710×16=2193w
        > 分支因子为 500 的 4KB 页面的四级树可以存储多达 256TB 。 (分支因子即为一个页面有多少个页面引用。此处一个页面有500个页面引用)
        > 
        
    ---
    
  - 索引的匹配方式
    - 全值匹配: 和索引中的所有列进行匹配
    - 匹配最左前缀: 只匹配前面的几列
    - 匹配列前缀: like查询时 ’column%' 才会走索引。否则索引无效
    - 匹配范围值: > < 这种。索引的使用截至到范围列，后续列就算在联合索引中，依然失效
    - 只访问索引的查询: 针对组合索引，select 的字段即为 组合索引的列，不进行回表操作
    - 组合索引的查找，需要注意正确的顺序依赖于该索引的查询，同时需要考虑如何更好的满足排序和分组的需要
    - **注意**:索引要完全按照对应的字段类型来赋值，否则索引失效
    
    ---
    
  - 聚簇索引与非聚簇索引
    - 聚簇索引: 根据主键来构建，叶子节点存放该主键对应的一行记录。主要针对innodb。innodb引擎中，索引和数据全部都放在一个文件中
    - 非聚簇索引: 数据文件跟索引文件分开存放。myisam引擎，.frm存储表定义，.myi文件存储索引文件，.myd文件存储数据文件。索引文件中，存储的是索引对应的数据地址
    
    ---
  - 覆盖索引
    - 概念: 如果一个索引包含所有需要查询的字段的值，称之为覆盖索引；覆盖索引必须要存储索引列的值；memory不支持覆盖索引
    - 优势:
      - 索引条目一般都远小于数据行大小，若只需读取索引，则会极大的减少数据访问量
      - 索引按列值的顺序存储，所以对于IO密集型的范围查询会比随机从磁盘读取一行数据的IO少的多
      - myisam在内存中只走缓存，数据则依赖于操作系统，可能会导致严重的性能问题
      - innodb的聚簇索引，覆盖索引对innodb表特别有用
      
    ---
  - 优化小细节
      - 使用索引列查询时，尽量不要使用表达式，把计算放到业务层中
      
      - 尽量使用主键查询，而不是其他索引
      
      - 使用前缀索引。
      
        > 针对索引很长的字符串，会占用很大的空间，可能导致树的高度过高，IO变多，查询慢。可以采用前缀索引的方式创建对应索引———只选择字符串的前几位，需要通过计算来确定取第几位。alter table citydemo add key(city(7)); 但mysql的前缀索引无法做order by 和 group by操作)
      
      - 使用索引扫描来排序。尽量保证 extra 中不出现 using filesort 。
      
      - union all,in,or都能使用到索引，但是推荐使用in
        - union all 通过explain会出现两条查询，in和or都只有一条，但通过 show profiles查看，in的查询时间要比or的时间短
        - union操作主要是合并两个select语句的结果集。如果必须使用union的情况下，首先考虑union all，之后考虑 union 操作，因为union有distinct操作还会进行默认规则的排序，更耗时。union all只是取并集，包含重复行，不排序。
        - in和exists的区别
          - in查询的逻辑：首先查询子查询的表，然后将内表和外表做笛卡尔积，按照条件筛选。内表较小的时候，in的速度较快。in不对null做处理
          - exists的逻辑：exists是通过双层for循环的方式，先查询外层循环，每查询出一条，执行exists内部的条件是否成立，成立则返回。
          - 区别和场景:如果子查询得出的结果集记录较少，主查询中的表较大且又有索引，用in；反之外层的主查询记录少，子查询中的表大，又有索引，用exists。
          - not in 和 not exists:not in 内外表都进行全表扫描；not exists的子查询依然能用表上的索引。
        
      - 范围列可以使用到索引 (<,<=,>,>=,between)，但范围列之后的列无法使用索引
      
      - 强制类型转换会导致索引失效，从而全表扫描
      
      - 更新十分频繁、数据区分度不高的字段上不宜建立索引
        - 更新会变更B+树，更新频繁可能会导致页合并、页分裂，降低数据库性能
        - 类似于性别这种区分不大的属性，建立索引是没有意义的
        - 区分度在80%以上的就可以建立索引了(count(distinct(列名))/count(1)计算区分度)
        
      - 创建索引的列，尽量不允许null
      
      - 当需要表连接的时候，最好不要超过三张表，同时join的字段，数据类型必须一致
        
        - join相关：mysql只支持一种JOIN算法Nested-Loop Join(嵌套循环链接)，不过其有很多变种，帮助提高mysql更高效的查询
          1. Simple Nested-Loop Join 普通嵌套循环链接：从驱动表中取出R1匹配S表所有列，然后R2，R3，直到将驱动表R表中的所有数据匹配完，然后合并数据。循环R×S次，效率低。
          2. Index Nexted-Loop Join 索引嵌套联系：非驱动表(S表)上有索引，直接通过索引来比较。查询时，驱动表根据关联索引进行查找，在索引上查找到符合的值，在进行回表查询。
          3. Block Nested-Loop Join :当join的列没有索引时，mysql会优先使用 该算法。该算法会提取出一个join buffer，将驱动表的相关join列记录到缓冲join buffer中，然后批量与非驱动表比较。可以通过join_buffer_size设置join buffer的值，默认为256K
          4. 疑问:join和where在一条语句中，执行顺序的问题。如下面两个sql
          explain SELECT a.a , b.b FROM `a` a left join b b on a.a = b.a ;
          explain SELECT a.a , b.b FROM `a` a left join b b on a.a = b.a where a.a = 1;
          explain的结果中，第一条语句的第一个查询，type=index，第二条语句的第一个查询，type=const (感觉是先定位了where，但where不是在join之后么？)
          explain SELECT a.a , b.b FROM `a` a left join b b on a.a = b.a and a.a = 1;
          该语句的结果，第一个查询 type也是为index
    - 能使用limit得情况尽量使用limit 。limit的作用是限制查询(分页是对应的应用之一)。加了limit之后，当匹配的量符合limit数量即停止。
    - 单表索引建议控制在5个以内。索引太多，对应占的内存越大，IO次数越大，效率越低。
    - 索引若是组合索引，则字段数不建议超过5个
    - 索引不是越多越好，需要在合适的情况下创建索引，并对索引进行优化
    
    - 索引监控: **show status like 'Handler_read%';** 展示当前会话中，查询使用到索引的情况，共有七条，下面只简述其中的较为重要的两条
        - Handler_read_first：读取索引第一个条目的次数。该项表明SQL是在做全索引扫描。该数值大，既是好事也可能是坏事。好事:说明查询是在索引里，不是在数据文件里；坏事:即使全扫描，如果数据量很大，索引全扫描也是一件很费时的事。
        - Handler_read_key：通过index获取数据的次数。该字段的值越大越好，说明系统高效的使用了索引。
  
---

- ### 索引的最左匹配
  > https://blog.csdn.net/qq_31442743/article/details/117621441
  > 
  
  - 为什么创建联合索引会遵从最左匹配原理呢?  
      - mysql底层使用的是B+树，那么非叶子节点都是索引，只有最后的叶子节点存储数据。当使用联合索引的时候，由于B+树的key只能存一个，所以联合索引的叶子节点都是用最左的索引。
  非叶子节点都是有序的，当到了叶子节点，第一列是有序的，然后第二列也是有序的(类似于一个单链表的形式)。。直到数据的地址。基于这个原因，最左匹配原则查询的时候，必须带上最做的索引


- ### 查询优化
  
  ​      
  

