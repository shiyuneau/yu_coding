## mysql锁机制
---
> 参考马士兵mysql调优相关文档，及其余网页链接
>
> 间隙锁参考连接 <https://www.jianshu.com/p/d5c2613cbb81>

---

- 主要的锁机制
  - **表级锁:** 开销小，加锁快; 不会出现死锁；锁定力度大，发生锁冲突的概率最高，并发度最低。
  - **行级锁:** 开销大，加锁慢; 会出现死锁；锁定力度小，发生锁冲突的概率最低，并发度也最高。

---

- MyISAM存储引擎
  - myisam使用的是**表锁**
  - 表锁实现
    - 表共享读锁(Table Read Lock):不会阻塞其他用户对同一表的读请求，但会阻塞对同一表的写请求
    - 表独占写锁(Table Write Lock):会阻塞其他用户对同一表的读和写操作
    - 同时，myisam表的读操作与写操作之间、以及写操作之间，是串行的。
  - 具体说明
    - 写锁阻塞读: session a 使用 lock table tablename write; 加上写锁。session a 依然可以对该表进行查询、插入、更新操作；session b 对该表的所有操作都会被阻塞。
    - 读锁阻塞写:session a 使用 lock table tablename read; 加上读锁。session a只能读取当前表数据，不可读取其他表、更新当前表、更新其他表；session b 允许对该表的查询权限，更新、插入无权限，对其他未锁定的表无限制。
  - **注意:** 
    - myisam执行语句前，会自动给涉及的表加对应读锁或者写锁，无需显式加锁。
    - 若同时一个读请求、一个写请求，myisam会优先处理写请求，因此myisam不适用于大量写请求的系统
    - 可使用 **show status like 'table%'**命令查看以下两个状态，来确定表锁的竞争状态
      - Table_locks_immediate:能够立即获得表级锁的请求次数
      - Table_locks_waited:不能立即获得表级锁、需要等待锁请求的次数。**该值越大，锁竞争越激烈**

---

- Innodb存储引擎
  - **innodb既使用行锁，也使用读锁**
  - innodb的行锁模式及加锁方法
    - **共享锁(S锁):** 又称**读锁**。允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。若事务T对数据对象A加S锁，则事务T可以读A，但不能修改A，其他事务只能再对A加S锁，而不能加X锁，直到T释放A上的S锁。保证其他事务可以读A，但在T释放A上的S锁之前，不能对A做任何修改。
    - **排他锁(X锁):**又称**写锁**。允许获取排他锁的事务更新数据，阻止其他事务取得相同的数据集共享读锁和排他写锁。若事务T对数据对象A加上X锁，其他事务不能对A加任何锁，知道T释放A上的锁。
    - 加锁语句:
		update、delete、insert语句都会自动给涉及的数据行加上排他锁
		select语句默认不会加任何类型的锁
		显示加排他锁: select ... for update
		显示加共享锁:select ... lock in share mode
		加过排他锁的数据行在其他事务是不能修改数据的，也不能通过for update和lock in share mode锁的方式查询数据。但可以直接通过select .. from ..查询，因为普通查询没有任何锁机制。
    - innodb行锁的实现方式
      - innodb行锁是通过给**索引**上的索引项加锁来实现的。意味着:**只有通过索引条件检索数据，innodb才使用行级锁，否则innodb使用表锁**
  - innodb减少锁冲突和死锁思路:
    - 尽量使用较低的事务隔离级别: 精心设计索引，并尽量使用索引访问数据，使索引更精确，从而减少所冲突的机会。
    - 选择合理的事务大小，小事务发生锁冲突的几率更小。
    - 给记录集显示加锁时，最好一次性请求足够级别的锁。
    - 不同的程序访问一组表时，应尽量约定以相同的顺序访问表，对一个表而言，尽可能以固定的顺序存取表中的行，可以大大减少死锁的机会。
    - 尽量使用相等条件访问数据，这样可以避免间隙锁对并发插入的影响;不要申请超过实际需要的锁级别;除非必须，查询时不要显示加锁;
    - 对一些特定的事务，可以使用表锁来提高处理速度或减少死锁的可能
  - innodb引擎的其他两种锁
    - 间隙锁(Gap Lock) : 在innodb引擎中，隔离级别为 **可重复读**(RR,默认的隔离级别)会产生幻读的情况。innodb通过在 当前读 的情况下，使用行锁+间隙锁 得方式来避免幻读的发生。
    间隙锁的唯一作用就是在一定的"间隙"内，防止其他事务的插入操作，以方式幻读的发生。
      - 防止间隙内有新数据被插入
      - 防止已存在的数据，更新成间隙内的数据
    - next-key lock : 行锁和间隙锁组合起来就是 Next-Key Lock 
    - 间隙锁的使用概述:
      innodb默认的隔离级别是可重复读(Repeatable Read),并且会以Next-Key Lock的方式对数据行进行加锁。Next-Key Lock是行锁和间隙锁的组合，当innodb扫描索引记录的时候，会首先对索引记录加上行记录锁(Record Lock)，再对索引记录两边的间隙加上间隙锁(Gap Lock)。加上间隙锁之后，其他事务就不能在这个间隙修改或者插入记录。
      当查询的索引含有唯一属性(唯一索引、主键索引)时，innodb存储引擎会对next-key lock进行优化，将其降为行锁，即锁住索引本身，而不是范围。
    - 何时使用行锁、何时使用间隙锁
      - 只使用唯一索引查询，并且只锁定一条记录时，使用行锁
      - 只使用唯一索引查询，但索引条件时范围检索，或者唯一检索然而检索结果不存在(试图锁住不存在的数据)时，会产生Next-Key Lock
      - 使用普通索引检索时，不管是何种查询，只要加锁，都会产生间隙锁
      - 同时使用唯一索引和普通索引时，由于数据行时优先根据普通索引排序，再根据唯一索引排序，所以会产生间隙锁