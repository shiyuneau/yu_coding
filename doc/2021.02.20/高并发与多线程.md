## 高并发与多线程
>主要参考 mashibing 相关课程
> 《Java并发编程的艺术》
> 《Java高并发编程详解》


---

### 进程与线程，进程、线程的概念
> 进程是指处于运行过程中的程序，并且具有一定的独立功能。进程是系统进行资源分配和调度的一个单位，当程序进入内存运行时，即为线程
>
> 线程是进程的组成部分，一个进程可以拥有多个线程，而一个线程必须拥有一个父进程，线程可以拥有自己的堆栈、程序计数器、局部变量，但不能拥有系统资源。它与父进程的其他线程共享该进程的所有资源。
>
> 参考链接：<https://www.zhihu.com/question/33515481>

- #### 线程:
  - 进程中负责程序执行的执行单元
  - 依靠程序执行的顺序控制流，只能使用程序的资源和环境，共享进程的全部资源
  - 有自己的堆栈和局部变量，没有单独的地址空间
  - CPU调度和分派的基本单位，持有程序计数器，寄存器，堆栈
  - 独立运行，当前线程不知道进程中是否还有其他线程存在
  - 执行是抢占式的，当前执行的线程随时可能被挂起，以便运行另一个线程
- #### 进程的特点:
  - **独立性**：进程时系统中独立存在的实体，可以独立拥有资源，每个进程都有自己独立的地址空间，没有进程本身的运行，用户进程不可以直接访问其他进行的地址空间。
  - **动态性**：进程和程序的区别在于 进程是动态的，进程中有时间的概念，进程具有自己的生命周期和各种不同的状态。
  - **并发性**：多个进程可以在单个处理器上并发执行，互不影响。
- #### 并发与并行的区别:
  - **并发(concurrent)**：
    - 解释1：旨在任务提交的时候，好多个任务可以同时提交，看似多个任务在同时运行
    - 解释2：有处理多个任务的能力，但不一定要同时(宏观并行，微观串行)
  - **并行(parallel)**：
    - 解释1(对应并发解释1)：旨在任务执行的时候，多个任务可以同时处理(多核CPU同时处理)，并发的子集
    - 解释2(对应并发解释2)：有同时处理多个任务的能力。(需要多核CPU)
- #### 用户线程和内核线程(待完善)
- #### Java与线程(待完善)
  
---

### java线程基础
- #### 线程的创建和启动
  - 继承Thread类，重写run方法，调用实例的start方法运行
  - 实现runnable方法，重写run方法，创建runnable实现类的实例，传递个Thread对象，调用start方法
  - 通过Executors方法采用线程池的方式创建
  - 还可以使用Callable和future创建带有返回值的线程
- #### 线程优先级
  - 线程优先级决定线程需要多或者少分配一些处理器资源的线程属性。Java线程通过priority整型变量控制优先级，通过setPriority()方法修改，默认优先级为 **5**，优先级高的线程分配时间片的数量要多于优先级低的线程。但需要注意的是，**系统环境有很大的概率会忽略线程优先级的设置**。
- #### 线程的状态
> 线程状态的转换图 ![avatar](../../imgs/线程状态转换图.jpeg)
> 同步队列、等待队列的讲解可参考<https://blog.csdn.net/pange1991/article/details/53860651>
>

  - new：初始状态，线程被调用，但还没有调用start()方法
  - runnable：运行状态，将操作系统的就绪状态和运行状态，笼统地称作 运行中 
    - ready：就绪状态，在cpu的等待队列，有资格运行，但调度程序没有选到你
    - running： 获取到cpu时间片，开始执行线程里的方法
  - waiting：等待状态，线程进入等待状态，需要等待其他线程通知或中断
  - timed_waiting：超时等待状态，该状态不同于waiting，可以在指定的时间自行返回
  - block：阻塞，没有拿到锁
  - terminated：终止状态，表示当前线程已经执行完毕 
- #### 线程的方法
  - sleep方法: 让当前线程阻塞一段时间，如果在同步方法中调用不会释放对象的锁，时间到了之后会主动退出阻塞，可中断方法，被中断后收到中断异常。为Thread类特有的方法
  - wait/notify/notifyall方法：Object类的方法，所以必须在同步方法中调用。wait方法会释放对象的锁，其他的线程也可以抢占该资源。对象调用wait方法会加入等待队列，需要调用对应的notify/notifyall方法重新将线程加入同步队列中(同步队列中的线程为准备竞争锁的线程)
  - join方法：t1,t2线程启动后，分表调用t1.join，t2.join，可以保证t1先让出时间片，等待t2执行完之后，在继续执行
  - yeild方法：提醒调度器当前线程愿意放弃当前的CPU资源，若cpu资源不紧张，则忽略这个提示。不常用。
- #### interrupt
  - 中断的概念：当线程调用阻塞方法进入阻塞状态时，存在一直阻塞、无法释放锁或死锁的情况。调用对应线程的interrupt方法，会打断这种阻塞，并抛出InterruptedException异常。
  - 实现：每个线程内部存在着名为 interrupt flag得标识，如果线程被interrupt，其flag将被设置。**对于非阻塞中的线程, 只是改变了中断状态, 即Thread.isInterrupted()将返回true; 对于可取消的阻塞状态中的线程, 比如等待在这些函数上的线程, Thread.sleep(), Object.wait(), Thread.join(), 这个线程收到中断信号后, 会抛出InterruptedException, 同时会把中断状态置回为true.但调用Thread.interrupted()会对中断状态进行复位。但实践发现，对于可中断方法**
  - **注意**：设置interrupt只是将该标志位重置，但并不会让线程中断。**在Core Java中有这样一句话：”没有任何语言方面的需求要求一个被中断的程序应该终止。中断一个线程只是为了引起该线程的注意，被中断线程可以决定如何应对中断 “**   如果想让一个线程中断之后停止，需要使用辅助变量进行停止。
  
---

### JMM内存管理
- #### Java内存模型
  - 主要解决得问题是 线程之间的通信问题和线程之间的同步问题。
  - Java的并发采用共享内存模型，Java线程之间的通信总是隐式进行，整个通信过程完全透明。
  - 结构:
    - 主内存(Main Memory)：线程之间的共享变量存储在主内存。
    - 本地内存(Local Memory)：每个线程都有一个私有的本地内存，存储了该线程以读/写共享变量的副本。本地内存是JMM的一个抽象概念，并不真实存在，涵盖了缓存，写缓冲区，寄存器及其他的硬件和编译器优化。
  - 线程A和线程B通信的过程:
    - 线程A把本地内存A中更新过的变量刷新到主内存中。
    - 线程B到主内存中去读取线程A之前更新过的共享变量。
- #### 重排序
  - 从java源代码到最终实际执行的指令序列，会经历下面三种重排序:
    - 编译器优化重排序：编译器在不改变单线程程序语义的前提下，重新安排语句的执行顺序。JMM的编译器重排序规则会禁止特定类型的编译器重排序。
    - 指令级并行重排序：属于处理器重排序。对于处理器重排序，JMM的处理器重排序规则会要求Java编译器在生成指令序列时，插入特定类型的内存屏障。
    - 内存系统重排序：属于处理器重排序
  - JMM属于语言级的内存模型，确保在不同的编译器和不同的处理器平台之上，通过禁止特定类型的编译器重排序和处理器重排序，为开发人员提供一致的内存可见性保证。


---

### synchronized和volatile

---

### cas的实现类及面试题(生产者和消费者，交替打印)

---

### AQS实现原理，源码简析

---

### ThreadLocal原理及简要分析

---

### 容器与并发容器

---

### 线程池ThreadPoolExecutor 及ForkJoinPool及Executors

